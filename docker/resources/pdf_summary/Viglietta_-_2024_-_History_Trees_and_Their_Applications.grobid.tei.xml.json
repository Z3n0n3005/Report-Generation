{
  "id": 1661801320568427873,
  "name": "Viglietta_-_2024_-_History_Trees_and_Their_Applications.grobid.tei.xml",
  "segments": [
    {
      "header": "Introduction",
      "content": "these networks generally operate in synchronous or asynchronous communication steps, where agents send messages through the links of a (multi)graph, which may be static or dynamic, directed or undirected, connected or disconnected, etc.a network is anonymous if its agents are initially indistinguishable, i.e., they lack unique identifiers and can only be told apart by external input or due to the network's layout.\nin such networks, it is typically assumed that all agents run the same local deterministic algorithm.\nthis process is analyzed using standard stochastic methods to understand how these weights eventually converge to a common value.although this \"averaging technique\" enabled the development of general algorithms for anonymous networks, one of its major limitations is its disregard for the network's structural and topological characteristics, providing minimal insight into these aspects.\nfurthermore, analyzing these algorithms tends to be technically cumbersome, yielding only asymptotic estimates for how quickly the network reaches convergence or stability.another line of research, initiated by angluin, explores discrete and algebraic structures, such as the views of yamashita-kamedaand the graph fibrations and minimum bases of boldi-vigna.\nthis approach allows algorithms to fully leverage the network's structure and usually permits a more precise analysis of running times.\nhowever, the theoretical frameworks of views and graph fibrations were developed for networks with unchanging topologies, and their successful application has been limited to such static networks.history trees are a newer data structure that inherently includes a temporal dimension and was specifically designed for networks with dynamic topologies.\nthe introduction of history trees has recently led to the development of optimal linear-time algorithms for anonymous dynamic networksand state-of-the-art general algorithms for congested anonymous dynamic networks.in section 2, we outline the basic architecture of history trees, drawing comparisons with yamashita-kameda's views and boldi-vigna's minimum bases.\nadditionally, we showcase a straightforward linear-time algorithm for dynamic networks that illustrates the practicality of history trees."
    },
    {
      "header": "Basic Structure and Algorithms",
      "content": "the history tree h g of a network g is an infinite tree subdivided into levels, as in figure, where the nodes in level l t represent the equivalence classes of agents that are indistinguishable at time t.\nthe two views are matched and merged starting from the roots, v gets a child v \u2032 , and a new red edge from u to v \u2032 is added.and u \u2208 l t , indicates that, at step t, each agent represented by node u receives exactly m (identical) messages from agents represented by v.assuming that their internal memory and message sizes are unbounded, the agents in a network g can locally construct portions of the history tree called views.\nmore precisely, if an agent p at time t is represented by a node v \u2208 l t , then the view v t g (p) is defined as the portion of h g spanned by all directed paths from the root r to v, using black and red edges indifferently (black edges are assumed to be directed away from the root r).\nthe node v \u2032 is now the bottom of v t+1 g (p) and represents p (and possibly other agents) at time t + 1.it is a simple observation that the view v t g (p) contains all the information that p can possibly extract from the network g after t communication steps.we will now focus on static anonymous networks, which are well understood thanks to the works of yamashita-kameda, boldi-vigna, and other authors.if g is a static network of n agents, once the classes of indistinguishable agents remain unchanged for a single communication step, they must remain unchanged forever.\nwhile it is important not to confuse these two concepts, they bear a deep relationship illustrated in figure.for yamashita and kameda, the view t g (p) of an agent p in a static network g is an infinite tree rooted at p, where each node of depth k represents a distinct 2 by treating the disjoint union of the two networks as a single network of size 2n, it becomes evident that agents that are indistinguishable at time t = 2n -1 are indistinguishable forever.\na static network g with a distinguished agent p and its history tree hg (truncated at level l4).\nin figure, for instance, since level l 0 is non-branching in the highlighted view (because node b 3 is not in the view), at time t = 2 the cyan agents may be deceived and incorrectly deduce that 3a(a 1 ) = 2a(a 2 ).recall that the network is assumed to be connected at all steps.\nindeed, if k < n agents have some information at time t, then at least k + 1 agents have it at time t + 1.hence, it takes at most d steps for a node in the history tree to appear in the views of all agents."
    },
    {
      "header": "Leader Election",
      "content": "in this case, any agent that becomes distinguishable from all others at time t can be identified with certainty by time t + 2n -2, allowing all agents to terminate.in section 2.3 we gave a counting algorithm for connected undirected dynamic networks with a unique leader that stabilizes in 2n -2 steps.\nsince the network is connected at all steps, it can be shown that only 2n -2 levels of the history tree are required for this algorithm to eventually identify nodes with correct guesses on all branches.adding up the anonymities of nodes on all branches produces an estimate n \u2032 on the actual size of the network, n.\nto confirm this estimate, it is sufficient to wait an additional n \u2032 steps, which is the longest time it may take for at least one missing branch to appear in the view, if one exists.overall, this counting algorithm terminates in 3n -2 steps in the worst case, leaving a small gap with the lower bound of 2n -2 steps given in section 2.3.steps in all connected undirected dynamic networks with a unique leader?the previous counting algorithm was generalized into networks where the leader may not be unique, but there is a known number \u2113 \u2265 1 of indistinguishable leaders, or supervisors.\nin other words, the nullity of a is 1, which means we can solve the linear system in terms of a single free variable.thus, we can find the ratios between the anonymities of all nodes in l i , or compute them exactly if there is a known number \u2113 \u2265 1 of leaders in the network.this technique yields stabilizing average consensus and counting algorithms for strongly connected directed dynamic networks with late outdegree awareness, generalizing the ones in section 2.3.\nthe history tree architecture for outdegree awareness of section 3.3 can also be adapted to this model by simply attaching a port number to each red edge.as an example, output port awareness combined with a unique leader makes the counting problem particularly simple even in strongly connected directed dynamic networks.\ncan a counting algorithm terminate in fewer than 2n -2 steps in all strongly connected directed dynamic networks with output port awareness and a unique leader?a less obvious fact is that, in any non-branching level of the history tree of a strongly connected directed dynamic network with output port awareness, all nodes must have the same anonymity.indeed, if a and b are two classes of indistinguishable agents represented by nodes in a non-branching level, and an agent in a receives a message tagged k from an agent in b, then so do all agents in a (or else their node would branch).\na terminating algorithm for both problems, if n is known, is easily obtained by combining the leader election algorithm in section 3.1 (which was designed for undirected networks only) with the stabilizing technique for directed networks in section 3.3.suppose that agents have inputs that may change at every step.\nwe remark that most existing self-stabilizing protocols, such as boldi-vigna's, are specifically designed for static networks, and cause agents to perpetually and incorrectly reset their states when executed in highly dynamic networks.we will give a universal self-stabilizing protocol that constructs coherent views, allowing to convert any stabilizing algorithm into a self-stabilizing one (note that non-trivial terminating computations are impossible in this scenario).the core idea is that an agent can deliberately \"forget\" old information by deleting level l 0 of its current view, connect level l 1 to the root, and merge equivalent nodes from top to bottom to restore a well-formed view, as in figure.if the number of agents n is known, they can simply update their views as usual (resetting their state if it does not encode a well-formed view) and delete old levels when their number exceeds some fixed threshold, e.g., 2n -2.\neventually, this protocol produces views that correctly describe the last 2n-2 communication steps, which are enough for the stabilizing algorithms of sections 2.3 and 3.3.on the other hand, if n is unknown, every agent updates its view as usual, but deletes level l 0 every two steps.\ncan a counting algorithm terminate in o(n 2 ) steps in all congested dynamic networks with a unique leader?we find it fitting to conclude this note with an open problem that is unlikely to have a solution using history trees.open problem 13."
    }
  ]
}
