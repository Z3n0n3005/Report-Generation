{
  "id": 8628790394590343025,
  "name": "Raposo_et_al._-_2024_-_Mixture-of-Depths_Dynamically_allocating_compute_.grobid.tei.xml",
  "segments": [
    {
      "header": "Introduction",
      "content": "not all problems require the same amount of time or effort to solve. analogously, in language modeling not all tokens and sequences require the same time or effort to accurately make a prediction. and yet, transformer models expend the same amount of compute per token in a forward pass. ideally, transformers would use smaller total compute budgets by not spending compute unnecessarily.conditional computation is a technique that tries to reduce total compute by expending it only when needed. various algorithms offer solutions to when and how much compute should be used. however, general formulations of this challenging problem may not work well with existing hardware constraints since they tend to introduce dynamic computation graphs. the most promising conditional computation methods may instead be those that are harmonious with our current hardware stack, which prioritizes static computation graphs, and known tensor sizes that are selected to maximize hardware utilization.here we consider the problem of language modeling using a static compute budget that can be made less than that used by a vanilla transformer. the network must learn how to dynamically allocate the available compute by making decisions per-token, in each layer, about where to spend compute from the available budget. in our implementation total compute is user defined and unchanging prior to training, rather than being a function of the network's on-the-fly decisions. thus, hardware efficiency gains-such as reduced memory footprint, or reduced flops per forward pass-can be anticipated and exploited ahead of time. as we will show, these gains can be had without sacrificing overall performance.we leverage an approach akin to mixture of experts (moe) transformers, in which dynamic token-level routing decisions are made across the network depth. departing from moe, we choose to either apply a computation to a token (as would be the case for a standard transformer), or pass it through a residual connection (remaining unchanged and saving compute). also in contrast to moe, we apply this routing to both forward mlps and multi-head attention. since this therefore also impacts the keys and queries we process, the routing makes decisions not only about which tokens to update, but also which tokens are made available to attend to. we refer to this strategy as mixture-of-depths (mod) to emphasize how individual tokens pass through different numbers of layers, or blocks, through the depth of the transformer (see figure).the mod technique also allows one to trade-off performance with speed. on the one hand, one can train an mod transformer that improves upon vanilla transformers by as much as 1.5% on the final log probability training objective for equivalent training flops (isoflop), and while taking an equivalent amount of wall-clock time to train. on the other hand, one can train an mod transformer that achieves training loss parity with an isoflop optimal vanilla transformer, but which uses a fraction of the flops (upwards of 50%) per forward pass, and hence is faster to step. together, these results imply that mod transformers learn to route intelligently (i.e., skipping computations that are unnecessary) since they can achieve equal or better log probabilities per sequence despite a smaller flop footprint per forward pass."
    },
    {
      "header": "Background",
      "content": "the transformer architecture has become the workhorse of a revolution in practical artificial intelligence, bringing unprecedented capabilities at the cost of expensive training runs and serving procedures. this has spurred tremendous interest in making transformer architectures more efficient. one of the promising approaches is conditional computation, whereby learned mechanisms determine when and how to expend computation. this terminology was introduced by bengio (2013), and the concept was explored further over the next several years.a wide variety of recent work has developed conditional computation methods for transformers. some of this work focuses on \"early exiting\", that is, learning to decide when to end computation on a given token, allowing the token to skip any remaining transformer layers after the exit decision is made. in mod, unlike in early-exit methods, a token can skip middle layers, then be updated via self-attention with tokens that that have gone through all the middle layers. we speculate that this might be a useful property.other work has developed methods for iterating transformer layers with shared weights for an adaptive number of steps.developed a method for choosing tokens to merge when running inference on a trained vision transformer which notably requires no learning.make use of conditional computation in a fine tuning setting by building on adapter approachesto learn to skip blocks of frozen pre-trained weights in favor of running only a small fine-tuned adapter.colt5uses conditional routing to select whether a given token will pass through a heavy or light pathway for each feedforward layer. further, they use the same routing mechanism to select whether a token will attend to all other tokens or to a select few, as in. like mod, colt5 uses soft top-k for making routing decisions. however, colt5 focuses on a encoder-decoder setting, and thus does need to contend with the problem of efficient sequential decoding given the non-causal nature of the top-k operation. in contrast, our current work with since some tokens take this second route, mixture-of-depths (mod) transformers have a smaller total flop footprint compared to vanilla or moe transformers. on the top right is depicted a trained model's routing decisions for a short sequence truncated to 64 tokens for visualization purposes. when examining the choices one can find tokens processed by later blocks' layers, despite passing through relatively few total blocks throughout the model's depth. this is a unique feature of mod compared to conventional halting-based, or \"early-exit\" conditional computation, which instead engage blocks serially, or vanilla transformers, which engage every block.mod focuses on the decoder-only setting, and so we propose a predictive router to enable efficient inference for conditional computation in transformers.one successful formulation of conditional computation is the the \"mixture-of-experts\" layer (moe) as introduced by. developed initially in the context of lstms, later work showed compelling empirical results for moe with transformers. unlike other conditional computation approaches that try to conserve or expend additional compute, moe transformers use conditional logic to route tokens to one of many expert mlps while keeping total compute expenditure constant. our mixture-of-depths method can be thought of as using the routing logic from moe transformers, but rather than having multiple experts, mod deploys a single expert which can be dynamically skipped."
    },
    {
      "header": "Implementing Mixture-of-Depths Transformers",
      "content": "our high-level strategy is as follows:\u2022 set a static compute budget that is less than that of an equivalent vanilla transformer by limiting the number of tokens in a sequence that can participate in a block's computations (i.e., selfattention and subsequent mlp). for example, while a vanilla transformer might permit all the tokens in a sequence to participate in self-attention, we might limit the number to 50% of the tokens in a sequence. see section 3.1.\u2022 use a per-block router to emit a scalar weight for each token, which expresses the router's preference for that token to participate in a block's computations or to route around it. see section 3.2. \u2022 identify the top-\ud835\udc58 scalar weights (per sequence, per block) to select those tokens that will participate in a block's computations. since precisely \ud835\udc58 tokens will participate in the block's computations, the computation graph and tensor sizes remain static throughout training; it is merely the tokens' participation that is dynamic and context-sensitive, as determined by the router. see section 3.3.we then discuss some complications when sampling post-training in section 3.5.to enforce a total compute budget per forward pass we leverage the notion of capacity, which defines the total number of tokens that comprise the input to a given computation (e.g., the tokens participating in self-attention, a given expert in moe transformers, etc). for example, the self-attention and mlp in each vanilla transformer block have a capacity of \ud835\udc47-the total number of tokens across the sequence and batch. moe transformers, on the other hand, use a capacity less than \ud835\udc47 per expert mlp so as to more evenly divide the total compute across each expert. but, since they use multiple experts per block, their total capacity is approximately equal to that of a vanilla transformer.generally, it is the token capacity that determines the total flops for transformers that use conditional computation, rather than the outcomes of any routing decisions. this is because staticgraph implementations account for the worst-case scenarios decisions; e.g., a computation's inputs will be padded to its capacity amount even if relatively few tokens actually end up routing to it, and/or tokens will be dropped from the computation if the capacity is exceeded.we can achieve our goal of using a smaller compute budget per forward pass compared to a vanilla transformer by lowering the capacity of the computations. however, using a smaller compute budget haphazardly will result in a performance degradation. we hypothesize that certain tokens might not require as much processing as others, and these tokens can be identified through learning. therefore, if the network learns to choose the right tokens to fill up its capacities, then it may preserve its performance. in the following we describe routing schemes that can be used for this purpose.we consider the setting whereby we route tokens to one of two computational paths: (1) self-attention and mlp blocks, and (2) a residual connection. the latter is computationally cheap, and results in a block output that is entirely determined by the value of its input. the former path is computationally expensive.the total number of flops per forward pass will be fewer than that in a vanilla transformer if we set the capacity for path (1) to be anything less than \ud835\udc47 (the total number of tokens across the sequence and batch). for example, if we were to set a block's capacity to \ud835\udc47 2 (i.e., half the number of tokens as would be the case in a vanilla transformer) then query-times-key matrix multiplication during self-attention becomes 25% as flop-intensive as in a vanilla transformer (( \ud835\udc47 2 ) 2 vs. \ud835\udc47 2 ). similar calculations can determine the flop-savings for the mlp.intuitively, the total flops per forward pass decreases (and the time to complete a forward pass decreases) in proportion to how aggressively we shrink the blocks' capacities. however, downstream performance will also be affected by how aggressively we shrink the blocks capacities, and by the routing algorithm we implement.at one extreme, if we leave each block's capacity at \ud835\udc47 and route every token to (rather than around) each block, then we recover a vanilla transformer. at the other extreme, if we set each block's capacity to 0 and route all tokens around each block, then we're left with a very fast model that doesn't engage with the vast majority of the transformer's parameters, and undoubtedly has poor downstream performance. we hypothesize that somewhere between these two extremes is an optimal model that is faster than a vanilla transformer and performs as well, if not better, all while being faster to step.naively, one can leverage stochasticity to route tokens, akin to layer or block \"dropout\". we present this routing scheme as a control, and will show that it significantly under-performs relative to vanilla transformers.we hypothesize that learned routing is preferable. intuitively, the network should be able to learn which tokens require more or less processing than others. if we are correct that transformers often expend more compute than they need to make their predictions, then it is an empirical question as to how aggressively we can shrink each block's capacity, and hence, how many tokens we can afford to route around each block.there are two learned routing schemes we consider (see figure): token-choice and expert-choice. in token-choice routing, a router produces per-token probability distributions across computational paths (e.g., across expert identities in moe transformers). tokens are then shuttled to the path they prefer-i.e., that with the highest probability-and auxiliary losses ensure that all tokens don't converge to the same path. token-choice routing can have load balancing problems since there isn't a guarantee that tokens divide themselves appropriately between the possible paths. \"expert choice routing\" flips this recipe on its head: rather than having tokens choose the path they prefer, each path instead chooses the top-\ud835\udc58 tokens based on the tokens' preferences. this ensures a perfect load balance since \ud835\udc58 tokens are guaranteed to be shuttled to each path. however, it could result in over-or under-processing of some tokens, since some tokens may be among the top-\ud835\udc58 for multiple paths, or for none of them.we decided to leverage expert-choice routing for a few reasons. first, it obviates the need for an auxiliary balancing loss. second, since the top-\ud835\udc58 operation depends on the magnitude of the router weights, this routing scheme allows for relative routing weights to help determine which tokens most need the block's computations; routers can try to ensure that the most critical tokens are among the top-\ud835\udc58 by setting their weight appropriately, which is not possible with token-choice routing schemes. for our specific use-case, wherein one computational path is essentially a null operation, it might be critical that important tokens are routed away from the null operation. third, because we only route through two paths, a single top-\ud835\udc58 operation can efficiently split the tokens into two mutually exclusive sets, one for each computational path, preventing the over-or under-processing problem mentioned above.figure| routing schemes. tokens are funnelled to the computational path of their choice when using token-choice routing (left). if a given path exceeds its capacity (e.g., more than two tokens in this example) then surplus tokens must be dropped (purple token). the exact token that is ultimately dropped depends on the precise implementation in the underlying code. for example, priority is often given to those tokens that come earlier in the sequence or batch order. with expert-choice routing (middle), precisely \ud835\udc58 (in this case, two) tokens are chosen per path using a top-\ud835\udc58 mechanism across the tokens' router weights. here, tokens are dropped if they are not among the top-\ud835\udc58 with respect to any given path (orange token), and some tokens may even be funnelled to multiple paths (yellow token). in this work we deploy expert-choice routing (right). however, because we use just a single path, we leverage the implicit knowledge that tokens will be dropped if \ud835\udc58 is less than the sequence length so that we can route tokens away from the self-attention and mlp computations, thus expending fewer flops in a given forward pass of the model.as a reminder of the high-level intuition, each token is processed by a router to produce a scalar weight, and the top-\ud835\udc58 weights are then used to choose the token identities that will route through a transformer's block, which comprises self-attention and the subsequent mlp. suppose we have the set of token embeddings in a sequence of length \ud835\udc46 for a given layer \ud835\udc59; that is \ud835\udc4b \ud835\udc59 = {\ud835\udc65 \ud835\udc59 \ud835\udc56 |\ud835\udc56 is an integer, 1 \u2264 \ud835\udc56 \u2264 \ud835\udc46}. the router weight for a given token embedding is a scalar produced as a result of a linear projection, \ud835\udc5f \ud835\udc59 \ud835\udc56 = \ud835\udc64 \ud835\udc47 \ud835\udf03 \ud835\udc65 \ud835\udc59 \ud835\udc56 . our goal is to use these router weights to determine the output of a block's computation of each token. suppose \ud835\udc43 \ud835\udefd (\ud835\udc45 \ud835\udc59 ) is the \ud835\udefd-th percentile of the set of router weights \ud835\udc45 \ud835\udc59 , where \ud835\udefd = 1 -\ud835\udc36/\ud835\udc46 and \ud835\udc36 is the user-defined capacity per batch element (an integer < \ud835\udc46 that defines the number of tokens from a sequence that will be processed by a given function). a block's output for a given token is:here, x \ud835\udc59 is the set of tokens whose router values \ud835\udc5f \ud835\udc59 \ud835\udc56 > \ud835\udc43 \ud835\udefd (\ud835\udc45 \ud835\udc59 ) (that is, the \"top-k\" tokens), and \ud835\udc53 comprises self-attention and the subsequent mlp. note that the output for a given token \ud835\udc65 \ud835\udc59+1 \ud835\udc56 might depend on other tokens \ud835\udc65 \ud835\udc59 \ud835\udc56\u2260 \ud835\udc57 because of the self-attention operation. the cardinality of x \ud835\udc59 is \ud835\udc36 (or \ud835\udc58): the user-defined capacity. therefore, the mixture-of-depths transformer accrues compute savings relative to the baseline because the input to the block's computations \ud835\udc53 comprise fewer tokens than usual (\ud835\udc36 < \ud835\udc46), rendering the self-attention and mlp less expensive.notably, we multiply the output of the function \ud835\udc53 by the router weights. this puts the router weights along the \"gradient path\", thus subjecting them to the forces of gradient descent through the course of the language modeling task (we experimented with versions where the router weights are also included along the computational path for those tokens that bypass the block's computations, but it seems to be sufficient-and implementationally simpler-to only include the router weights along the computational path for those tokens that do not bypass the block's computations).while expert-choice routing has a number of advantages, it has one distinct problem: the top-\ud835\udc58 operation is non-causal. this means that whether a given token's routing weight is among the top-\ud835\udc58 for the sequence depends on the values of the routing weights for tokens that come after it, which we don't have access to when autoregressively sampling.we tested two methods to work around this problem. the first introduces a simple auxiliary loss that empirically affects the primary language modeling objective by approximately 0.2 -0.3%, but allows us to sample from the model autoregressively. we use a binary cross-entropy loss wherein the router's outputs provide the logits, and the top-\ud835\udc58 selections of these logits provide the targets (i.e. 1 if a token was among the top-\ud835\udc58, and 0 if not). intuitively, this loss centers the sigmoid of the router's outputs around 0.5; those tokens that are selected among the top-k are pressured to produce router outputs above 0.5, and those not among the top-k will be pressured to produce router outputs below 0.5. the second method introduces a small auxiliary mlp predictor (akin to a second router) that receives the same inputs as the router (with a stop gradient), but whose output is a prediction whether that token will be among the top-\ud835\udc58 or not in the sequence. this method does not affect the language modeling objective, and empirically does not significantly impact the step speed.equipped with these new methods, we can sample autoregressively by choosing to route tokens to or around a block based on the router's output, which does not depend on any information from future tokens. we provide empirical evidence that this is a relatively easy auxiliary task that quickly achieves 99% accuracy.all models use the same basic hyperparameter configurations (e.g. cosine schedules equal to 1\u00d7 the training steps, 128 batch size, 2048 sequence length) except for changes to the number of layers, heads, and embedding size to produce differently sized models during isoflop analyses."
    },
    {
      "header": "Results",
      "content": "we first trained models with a relatively small flop budget (6e18) to determine optimal hyperparameters (see figure). in general, we found that mod transformers drag the baseline isoflop curve \"down and to the right\". that is, the optimal mod transformer achieves a lower loss than the optimal baseline, and also has more parameters. a fortunate consequence of this effect is that there exist smaller mod models that, while they are not themselves isoflop optimal for their hyperparameter setting, are nevertheless as-or better-performing than the optimal baseline model while being faster to step. for example, a 220m parameter mod (figure 3 model #3) variant slightly outperforms figure| mod hyperparameter tuning. variants of the mod transformer were trained for 6e18 flops to determine the optimal hyperparameters for further isoflop analyses. on the left plot, the grey box indicates models that perform better than the isoflop optimal baseline. we found the best mod variant to be that which has the option to route every other block, and which uses a top-k of 256 (so, 256, or 12.5% of the sequence's tokens are processed by self-attention and the subsequent mlp, while 1792 tokens, or 87.5% of the sequence's tokens route around the block). shown on the right are the learning curves for a selection of models. notably, model #3 achieves equal performance to the isoflop optimal baseline but steps 66% faster, due to the relatively fewer flops needed per forward pass.the isoflop optimal baseline (also 220m, figure 3 model #1), but is upwards of 60% faster to step during training. crucially, when run on equivalent hardware these two model variants take take approximately the same amount of wall-clock time to train (figure).we tested routing every block or every other block, using capacities from 12.5% to 95% of the total sequence. while routing every other block was crucial for strong performance, we found that aggressive capacity reduction was best (gradual improvements were observed when reducing the capacity down to 12.5% of the total sequence, corresponding to 87.5% of tokens routing around blocks, with performance degrading beyond this point). so, it seems the network is robust to significant capacity reductions as long as there is frequent opportunity for full capacity self-attention and mlp computations.learned routing is crucial, as mod transformers that use stochastic routing (implemented using a top-\ud835\udc58 operation on router weights sampled from a gaussian distribution) perform drastically worse than both the baseline and normal mod transformer (figure).depicted in figureis an isoflop analysis for 6e18, 2e19, and 1e20 total flops. the trend that flop-optimal mod transformers have more parameters than the baseline continues for these larger flop budgets. notably, there exist mod variants that are appreciably faster to step than the isoflop-optimal baseline (measured as steps per second when training on equivalent hardware) while also achieving a lower loss (in figurewe depict normalized flops per forward pass rather than wall-clock step time per se, but from our experiments the two are tightly correlated. a similar plot can be produced showing relative wall-clock step times and the same basic trend is present).step-wise speed gains come from two sources. first, the flop-per-parameter ratio in mod figure| isoflop analysis. we used the 12.5% capacity mod variant to perform an isoflop analysis for 6e18, 2e19, and 1e20 flops, training models varying in size from 60m to 3b parameters. depicted on the right are the relative flops per forward pass (normalized to the isoflop optimal baseline).there exist mod variants that are both faster to step (by virtue of requiring fewer flops per forward pass) and better performing than the isoflop optimal baseline. transformers is less than in the baselines because some proportion of tokens are routed around blocks. so, for a given model size, a transformer requires fewer flops per forward pass. second, since isoflop-optimal mod transformers are both bigger and achieve a lower loss than the isoflop-optimal baseline, there exist smaller mod variants that perform as well or better than the isoflop-optimal baseline, and these variants are faster to step because they are smaller. altogether, then, there exist mod transformers that perform as well as isoflop-optimal baselines and are faster to step, both because they use fewer flops per parameter and because they use fewer parameters.figurealso reveals another important finding: the optimal mod transformer is that which uses as many flops per forward pass as the isoflop optimal baseline. this finding allows one to directly predict which sized mod transformer will perform optimally for a given isoflop training budget: one just needs to tune the model size for a given mod configuration (i.e., capacity and routing frequency) to produce a model that uses as many flops per forward pass as the isoflop-optimal baseline, and they will have the optimally performing mod variant for that configuration. empirically, we find that it is better to add depth than to add width when adding flops to the model. nevertheless, while the flops per forward pass determines which model will be the isoflop optimal, it does not predict whether the optimal loss will improve upon the baseline (see figure. namely, the optimal capacity appears to be empirically determinable. we found that it is best to use 12.5% capacity blocks, every other block.we noticed that mod transformers had memory savings relative to equivalently sized baseline models at larger sizes, with some variants requiring fewer total devices (i.e., a smaller tpu topology). we did not study this extensively, but we anticipate that as one scales to larger models, these savings could be an important consideration when choosing model variants to train, and could have significant positive effects in regards to the kv cache size during autoregressive sampling.figureshows the routing decisions for an mod transformer trained with interleaved routing blocks. despite aggressive routing around the blocks, transformers are able to achieve performance figure| routing analysis. we trained an mod transformer that interleaved 12.5% capacity routing blocks with full-attention blocks. as expected, the number of tokens that route to (rather than around) a block is sparse in routing blocks, though the network does sometimes preferentially route certain tokens to each block along its depth. this can be seen in the left figure that depicts routing decisions, where we observe a vertical band of dark blue towards the end of the sequence. as expected, the distribution of router weights are as the auxiliary loss dictates: approximately 12.5% of weights are above 0.5 and 87.5% are below.improvements relative to baselines. we observe patterns that might warrant further study; namely, some tokens appear to engage each block along the transformer's depth, while others decide to route around blocks whenever possible. preliminary analyses suggest that the tokens that engage with blocks more frequently are correlated with output predictions that have higher entropy, which possibly corresponds to predictions that are more difficult to make.we evaluated mod variants during auto-regressive sampling (see figure). each model was tested on exactly the same held-out data comprising 256000 sequences (500m tokens). when switching from the top-\ud835\udc58 routing method to the predictor-based routing method we observed little performance degradation. as in the training setting, there exist mod variants that are better performing than the isoflop-optimal baseline, while requiring fewer flops per forward pass. these results suggest that the compute savings offered by mod transformers should translate beyond the training setting.the mod technique can be naturally integrated with moe models (together comprising mode models) in addition to vanilla transformers. in figurewe present results showing that the performance improvments offered by mod compound with those of moe. we tried two variants: in staged mode, which routes tokens around or towards blocks prior to the self-attention step, and integrated mode, which implements mod routing by integrating \"no-op\" experts among the conventional mlp experts. the former is advantageous because it allows for tokens to skip the self-attention step, while the latter is advantageous because it simplifies the routing machinery. we noticed that implementing mode in the integrated manner was distinctly better than simply reducing the capacity of experts in conventional moe models, and relying on token dropping to implement residual routing. we believe this is because with the integrated mode machinery, tokens explicitly learn to choose the residual path around the experts, as opposed to preferring an expert but being dropped when implemented as figure| auto-regressive evaluation. switching from the non-causal top-\ud835\udc58 routing scheme in training to a causal predictor-based approach during auto-regressive sampling leads to minimal performance degradation. this is perhaps due to the ease of learning this prediction problem, which is upwards of 97% accurate soon into training. a capacity reduction."
    },
    {
      "header": "Discussion",
      "content": "mixture-of-depths transformers empirically demonstrate that one can improve on isoflop-optimal baseline performance with models that use fewer flops per forward pass. this means that-for a given training flop budget-we can train models that are both faster and better performing than their baseline counterparts. previously, to train models that are both faster and as-or better-performing than isoflop-optimal models, one would have to use surplus compute to overtrain smaller models (notably, this overtraining technique is still possible with mod transformers, and speed gains should compound).while mod transformers require fewer flops per forward pass, one cannot forego flops indiscriminately. rather, it is crucial to use learned routing decisions-much like in mixture-of-experts transformers-to determine whether a token should participate in self-attention and the subsequent mlp (requiring flops), or not (saving flops).we can then use any saved flops by, for example, making the model bigger or training it for longer. our results show that indeed flops may be inefficiently used in vanilla transformer models, and that there may be more efficient ways for them to be expended.learned routing mechanisms are sometimes non-causal; that is, information about the future is used to determine a given token's routing decision. this is generally true for top-k routing mechanisms, which are useful because they forego the need for auxiliary balancing losses. however, top-k routing mechanisms present difficulties in post-training autoregressive sampling, where it is impossible to use information about future token identities to determine routing decisions. in this work we show that one can successfully use a top-k routing scheme during training, but not require it during later autoregressive sampling. eiher a simple auxiliary classifier, or auxiliary loss on the router, is sufficient to learn the top-\ud835\udc58 routing decisions such that it can mimic the top-\ud835\udc58 decisions during autoregressive intuitively, a token might learn to route around blocks because the prediction being made at that step is easier, and hence, does not require as much compute. however, this strategy is undoubtedly not all that the network learns. if a token does not participate in self-attention at a certain block, then later tokens will also not be able to attend to it. thus, whether tokens decide to route or not impacts both the current step's prediction and future predictions via causal self-attention, and how the network balances these effects is guided by their influence on the overall language modeling objective.this insight opens the door to mod variants that decouple the routing for queries, keys and values. for example, perhaps a token would prefer to be among the queries, but not the keys, for a given self-attention computation. one can imagine extending this idea even further into the domain of \"long-term memory\": perhaps there are tokens that would be extremely valuable as keys, regardless of whether it is useful for them to also be among the queries at the step of their occurrence. learned routing could be a powerful mechanism for deciding which tokens these might be, perhaps funnelling them into a long-term memory buffer that is available during future self-attention. one advantage of such an approach to long-term memory is that tokens decide once, at the moment of \"memory encoding\", whether they should be retrieved in the future. this is more computationally efficient than performing a full content-based lookup across an entire memory buffer for each step in the future, and could be one step towards drastically increasing the context-length available for making a prediction.unlike moe transformers that route between effectively the same computation (usually mlps), mod transformers demonstrate the value of routing among different types of computations. in this work the types were either the conventional transformer block, or a null computation (functionally equivalent to multiplying by zero). however, one can imagine extending this idea further by routing between even more types of computation. for example, perhaps some tokens are routed to \"memory lookup\" functions, and others are routed to \"tool use\" functions. in general, the routing machinery we deployed provides a knob for adjusting the types of computations available to the network and their relative cost (in total flops); if one wants to introduce an expensive computation, then this can be offset by setting its capacity to some small amount, and hence, by routing only a small number of tokens to it.altogether, mod transformers are another tool one can use to tune a model's compute per forward pass (and hence inference time). the machinery used to implement mod is also generic, and opens the doors to many extensions and integration with other techniques, such as moe."
    }
  ]
}
